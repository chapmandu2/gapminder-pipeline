---
title: "Parallelised Analyses"
author: Phil Chapman
date: 2019-01-28
output: 
    html_document:
        number_sections: yes
        theme: cosmo
        highlight: tango
        toc: yes
        toc_depth: 3
        code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction



# Set up

## Load R libraries

```{r, message=FALSE}
library(dplyr)
library(purrr)
library(furrr)
library(ggplot2)
library(gapminder)
library(tidyr)
library(future)
```

# Working with computationally expensive models

## Previously

Previously we made multiple models with `purrr::map`

```{r}
nested_data <- gapminder %>%
  group_by(continent, country) %>%
  tidyr::nest() 

ptm <- proc.time()
many_models <- nested_data %>%
  mutate(mod = purrr::map(data, ~ lm(lifeExp ~ year, .)))
many_models
proc.time() - ptm
```

## Slow fitting models

In the previous example, the `lm` function is being run 142 times, once for each country. This is fine as the model fits very quickly, but what happens if the function is slower?

First let's define a function called `slow_lm` which goes to sleep for a period of time in addition to fitting the model

```{r}
slow_lm <- function(df, sleep=0) {
  Sys.sleep(sleep)
  lm(lifeExp ~ year, df)
}
```

Now when we fit the model, it takes longer (unsurprisingly):

```{r}
ptm <- proc.time()
many_models_slow <- nested_data %>%
  mutate(mod = purrr::map(data, slow_lm, sleep=0.02))
proc.time() - ptm

```

# Parallelisation

## Using furrr

The `furrr` library which allows us to use the `future` package and its abilities to do parallel computation:

```{r}
plan(multiprocess(workers=2))
ptm <- proc.time()
many_models_furrr <- nested_data %>%
  mutate(mod = furrr::future_map(data, slow_lm, sleep=0.02))
proc.time() - ptm
```

## Using foreach




