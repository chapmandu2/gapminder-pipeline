---
title: "Drake Pipeline"
author: Phil Chapman
date: 2019-01-29
output: 
    html_document:
        number_sections: yes
        theme: cosmo
        highlight: tango
        toc: yes
        toc_depth: 3
        code_folding: show
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Introduction



# Set up

## Load R libraries

```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(gapminder)
library(future)
library(drake)
library(clustermq)
```


# Drake pipeline

## Define functions

### Function to fit linear model

```{r}
slow_lm <- function(df, sleep=0) {
  Sys.sleep(sleep)
  lm(lifeExp ~ year, df)
}
```

### Function to plot slopes

```{r}
plot_slopes <- function(df) {
  ggplot(df, aes(continent, estimate, color = continent)) +
    geom_violin() +
    geom_point(position = position_jitter(width=0.3)) +
    theme_bw()
}

```

### Function to calculate slope

```{r}
calculate_slope <- function(df, country, sleep) {
  
  dat <- df %>%
    dplyr::filter(country == !!country)
  
  mod <- slow_lm(dat, sleep = sleep)
  
  dat %>%
    distinct(continent, country) %>%
    mutate_all(as.character) %>%
    mutate(estimate=coef(mod)[['year']])

}

calculate_slope(gapminder, 'New Zealand', 0)

```

## Set up simple plan

```{r}
drake::clean(destroy=TRUE)

gm_pipeline_simple <- drake_plan(
  data_simple = gapminder::gapminder,
  plot_simple = ggplot(data_simple, aes(x=year, y=lifeExp, group=country, color=continent)) + 
    geom_line(alpha=0.3) + theme_bw()
)
```

Run the plan:

```{r}
make(gm_pipeline_simple)
```

View output:

```{r}
readd(plot_simple)
```

## Set up more complex plan

```{r}
drake::clean(destroy=TRUE)

gm_pipeline_complex <- drake_plan(
  data = gapminder::gapminder,
  many_models = data %>%
    group_by(continent, country) %>%
    tidyr::nest() %>%
    mutate(mod = purrr::map(data, slow_lm)),
  results = many_models %>%
    mutate(tidy_mod = purrr::map(mod, broom::tidy)) %>%
    dplyr::select(-data, -mod) %>%
    tidyr::unnest() %>%
    dplyr::filter(term == 'year'),
  plot = plot_slopes(results)
)

```

Run the plan:

```{r}
make(gm_pipeline_complex)
```

View output:

```{r}
readd(results)
readd(plot)
```

## Set up very complex plan

Define the plan

```{r}
drake::clean(destroy=TRUE)

gm_countries <- gapminder %>% distinct(country) %>% 
  unlist() %>% unname() %>% as.character()

par_plan = drake_plan(
  data_par = gapminder,
  countries_par = unique(data_par$country) %>% as.character(),
  results_par = target(
    calculate_slope(df=data_par, country = country_val, sleep = 0),
    transform = map(country_val = !!gm_countries)
  ),
  results = target(
    bind_rows(results_par),
    transform = combine(results_par)
  ),
plot = plot_slopes(results),
  trace=TRUE
)
```

View the plan

```{r}
par_plan
```

Make the plan
```{r}
make(par_plan, verbose=0)
```

View the output
```{r}
readd(plot)
```

## Do it in parallel

```{r}
plan(multicore(workers=4))

drake::clean()
pt <- proc.time()
make(par_plan, parallelism = "future", jobs = 4, verbose=0)
proc.time() - pt

drake::clean()
pt <- proc.time()
make(par_plan, parallelism = "loop", verbose=0)
proc.time() - pt

drake::clean()
pt <- proc.time()
options(clustermq.scheduler = "multicore")
make(par_plan, parallelism = "clustermq", verbose=0, jobs=4)
proc.time() - pt

```

In this case loop is the quickest since the individual jobs are very fast.  Future is the slowest because of the overhead of the scheduler.  Clustermq is very fast as the workers are persistent.  All cases are slower than using furrr or even foreach, but when the individual tasks are bigger we will get a bigger benefit.
